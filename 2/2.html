<!DOCTYPE html>
<html>

<head>
    <title>2.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

html,footer,header{
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Custom MD PDF CSS
 */
html,footer,header{
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";

 }
body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///r%3A/2.Travail/1.Enseignement/Cours/_1.Outils/2.Developpement/1.SCSS/main.css" type="text/css"><link rel="stylesheet" href="file:///d%3A/rdaros/Cours/_1.Outils/2.Developpement/1.SCSS/main.css" type="text/css">
</head>

<body>
    <div style="text-align:center; margin-top: 1cm;">
    <h2>Київський політехнічний інститут імені Ігоря Сікорського</h2>
    <h2>Приладобудівний факультет</h2>
    <h3>Кафедра автоматизації та систем неруйнівного контролю</h3>
    <br><br><br>
</div>
<div style="text-align:center; margin-top: 5cm;">
    <h2>Лабораторна робота № 2</h2>
    <h2>ФУНКЦІЇ, ЩО ВИКОРИСТОВУЮТЬСЯ ДЛЯ АНАЛІЗУ ЗОБРАЖЕНЬ</h2>
</div>
<div style="text-align:right; margin-top: 5cm;">
<p>Студент: Погорєлов Богдан<br>
    Група: ПК-51мп<br>
</p>
</div>
<div style="text-align:center; margin-top: 5cm;">
2025 рік  <br><br><br><br>
</div>
<h1 id="%D0%BC%D0%B5%D1%82%D0%B0-%D1%80%D0%BE%D0%B1%D0%BE%D1%82%D0%B8">Мета роботи</h1>
<p>Вивчення  функцій  аналізу  зображень  та  придбання  практичних  навичок  їх<br>
використання.  Здобуття  практичних  навичок  побудови  гістограми  розподілу  яскравості<br>
зображення  в системі MatLab.</p>
<p>Таблиця 2.1</p>
<table>
<thead>
<tr>
<th>Варіант</th>
<th>Формат вхідних зображень</th>
<th>Кут</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>1. Rock.bmp 2. Rock.jpg 3 Rock.jpg</td>
<td>120,30,0</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>Отримати  півтонове  зображення  з  повнокольорового,  згідно  варіанту  таблиці  2.1,  1<br>
колонка  (1  формат  вхідних  зображень).  Еквалізувати    його.  Вивести  півтонове  та<br>
еквалізоване зображення та їх гістограми в одне вікно.</p>
</li>
<li>
<p>Отримати  з  повнокольорового  зображення  згідно  варіанту табл.2.1,  (2)  палітрове.<br>
Зменшити кількість кольорів палітрового зображення до 256. Еквалізувати його. Вивести<br>
палітрове та еквалізоване зображення та їх гістограми в одне вікно.</p>
</li>
<li>
<p>Знайти  двовимірну  взаємну  кореляційну  функцію  згідно  варіанту  табл.2.1  (3)    між<br>
вхідним  та  повернутим  на  кут    зображенням.  Графіки  отриманих  функцій  вивести  на<br>
екран в одне вікно.</p>
</li>
<li>
<p>Знайти  двовимірну  взаємну  кореляційну  функцію  згідно  варіанту  табл.2.1  (3,)    між<br>
вхідним  зображенням та  його негативом.  Графіки отриманих функцій вивести на екран<br>
в одне вікно.</p>
</li>
</ol>
<h3 id="%D1%85%D1%96%D0%B4-%D1%80%D0%BE%D0%B1%D0%BE%D1%82%D0%B8">Хід роботи:</h3>
<h3 id="%D0%BA%D1%80%D0%BE%D0%BA-1-%D0%BF%D0%BE%D0%B1%D1%83%D0%B4%D0%BE%D0%B2%D0%B0-%D0%BF%D1%96%D0%B2%D1%82%D0%BE%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%82%D0%B0-%D0%B5%D0%BA%D0%B2%D0%B0%D0%BB%D1%96%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D1%8C">Крок 1. Побудова півтонового та еквалізованого зображень</h3>
<ol>
<li>Завантажено повнокольорове зображення у форматі <strong>BMP</strong>.</li>
<li>Перетворено його у півтонове за допомогою функції <code>rgb2gray</code>.</li>
<li>Виконано еквалізацію гістограми яскравості за допомогою функції <code>histeq</code>.</li>
<li>Виведено початкове півтонове та еквалізоване зображення разом з їх гістограмами в одне вікно.</li>
<li>Результат збережено у файл.</li>
</ol>
<p>Лістинг 1</p>
<pre class="hljs"><code><div>img = imread(<span class="hljs-string">'rock.bmp'</span>);

g = rgb2gray(img);
eq = histeq(g); <span class="hljs-comment">%вирівнювання (еквалізація) </span>

customHist({g, eq}, {<span class="hljs-string">'півтонове'</span>, <span class="hljs-string">'півтонове еквалізоване'</span>}, []);

print(gcf, [mfilename(<span class="hljs-string">'fullpath'</span>) <span class="hljs-string">'.png'</span>], <span class="hljs-string">'-dpng'</span>, <span class="hljs-string">'-r300'</span>);
close(gcf);
</div></code></pre>
<p><img src="src/lr2_1.png" alt="alt text"><br>
Рис. 3 - Результ задачі 1</p>
<h3 id="%D0%BA%D1%80%D0%BE%D0%BA-2-%D0%BF%D0%BE%D0%B1%D1%83%D0%B4%D0%BE%D0%B2%D0%B0-%D0%BF%D0%B0%D0%BB%D1%96%D1%82%D1%80%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%82%D0%B0-%D0%B5%D0%BA%D0%B2%D0%B0%D0%BB%D1%96%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%B0%D0%BB%D1%96%D1%82%D1%80%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F">Крок 2. Побудова палітрового та еквалізованого палітрового зображення</h3>
<ol>
<li>Завантажено повнокольорове зображення.</li>
<li>Виконано перетворення у палітрове зображення з кількістю кольорів, обмеженою до <strong>256</strong> (<code>rgb2ind</code>).</li>
<li>Застосовано еквалізацію гістограми до отриманого зображення.</li>
<li>Виведено палітрове та еквалізоване палітрове зображення разом з їх гістограмами в одне вікно.</li>
<li>Результат збережено у файл.</li>
</ol>
<p>Лістинг 2</p>
<pre class="hljs"><code><div>img = imread(<span class="hljs-string">'rock.bmp'</span>);

[pal, map] = rgb2ind(img, <span class="hljs-number">256</span>); <span class="hljs-comment">%на палітрове з 256 кольорами</span>
eq = histeq(pal);

customHist({pal, eq}, {<span class="hljs-string">'палітрове'</span>, <span class="hljs-string">'еквалізоване палітрове'</span>}, map);

print(gcf, [mfilename(<span class="hljs-string">'fullpath'</span>) <span class="hljs-string">'.png'</span>], <span class="hljs-string">'-dpng'</span>, <span class="hljs-string">'-r300'</span>);
close(gcf);

</div></code></pre>
<p><img src="src/lr2_2.png" alt="alt text"><br>
Рис. 3 - Результ задачі 2</p>
<h3 id="%D0%BA%D1%80%D0%BE%D0%BA-3-%D0%BA%D0%BE%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D1%96%D0%B9%D0%BD%D0%B8%D0%B9-%D0%B0%D0%BD%D0%B0%D0%BB%D1%96%D0%B7-%D0%BC%D1%96%D0%B6-%D0%BE%D1%80%D0%B8%D0%B3%D1%96%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%BC-%D1%82%D0%B0-%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D0%B8%D0%BC-%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F%D0%BC">Крок 3. Кореляційний аналіз між оригінальним та повернутим зображенням</h3>
<ol>
<li>Завантажено зображення у форматі <strong>JPG</strong>.</li>
<li>Перетворено його у півтонове.</li>
<li>Виконано обертання зображення на кути, задані варіантом: <strong>0°, 30°, 120°</strong> (<code>imrotate</code>).</li>
<li>Обчислено двовимірну взаємну нормалізовану кореляційну функцію між вихідним та повернутим зображенням (<code>normxcorr2</code>).</li>
<li>Побудовано графіки обернених зображень та відповідних кореляційних функцій у вигляді як зображення, так і 3D mesh-графіка.</li>
<li>Результат збережено у файл.</li>
</ol>
<p>Лістинг 3</p>
<pre class="hljs"><code><div>img = imread(<span class="hljs-string">'rock.jpg'</span>);
gray_img = rgb2gray(img);

angles = [<span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">120</span>];
anglLen = <span class="hljs-built_in">length</span>(angles)+<span class="hljs-number">1</span>;

customPlot([anglLen, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], img, <span class="hljs-string">'Оригінальне'</span>);
customPlot([anglLen, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], gray_img, <span class="hljs-string">'Grayscale'</span>);

<span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:anglLen<span class="hljs-number">-1</span>
    <span class="hljs-built_in">angle</span> = angles(k);
    index = <span class="hljs-number">3</span>*k + <span class="hljs-number">1</span>;
    
    rotated_img = imrotate(gray_img, <span class="hljs-built_in">angle</span>, <span class="hljs-string">'bilinear'</span>, <span class="hljs-string">'crop'</span>);
    c = normxcorr2(rotated_img, gray_img); <span class="hljs-comment">% 2D нормалізована кореляція</span>

    customPlot([anglLen, <span class="hljs-number">3</span>, index], rotated_img, [<span class="hljs-string">'Повернуте: '</span> num2str(<span class="hljs-built_in">angle</span>) <span class="hljs-string">'°'</span>]);
    customPlot([anglLen, <span class="hljs-number">3</span>, index+<span class="hljs-number">1</span>], c, <span class="hljs-string">'Взаємна кореляційна'</span>);
    customMesh([anglLen, <span class="hljs-number">3</span>, index+<span class="hljs-number">2</span>], c, <span class="hljs-string">'Взаємна кореляційна'</span>);
<span class="hljs-keyword">end</span>

drawnow;
print(gcf, [mfilename(<span class="hljs-string">'fullpath'</span>) <span class="hljs-string">'.png'</span>], <span class="hljs-string">'-dpng'</span>, <span class="hljs-string">'-r300'</span>);
close(gcf);
</div></code></pre>
<p><img src="src/lr2_3.png" alt="alt text"><br>
Рис. 3 - Результ задачі 3</p>
<h3 id="%D0%BA%D1%80%D0%BE%D0%BA-4-%D0%BA%D0%BE%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D1%96%D0%B9%D0%BD%D0%B8%D0%B9-%D0%B0%D0%BD%D0%B0%D0%BB%D1%96%D0%B7-%D0%BC%D1%96%D0%B6-%D0%BE%D1%80%D0%B8%D0%B3%D1%96%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%BC-%D1%82%D0%B0-%D0%BD%D0%B5%D0%B3%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B8%D0%BC-%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F%D0%BC">Крок 4. Кореляційний аналіз між оригінальним та негативним зображенням</h3>
<ol>
<li>Завантажено зображення у форматі <strong>JPG</strong>.</li>
<li>Перетворено його у півтонове.</li>
<li>Створено <strong>негатив</strong> зображення (<code>imcomplement</code>).</li>
<li>Обчислено дві кореляційні функції:
<ul>
<li>двовимірну автокореляційну функцію (<code>xcorr2</code>),</li>
<li>двовимірну нормалізовану взаємну кореляційну функцію (<code>normxcorr2</code>).</li>
</ul>
</li>
<li>Побудовано графіки негативного та початкового зображення, а також отриманих функцій у вигляді зображень та 3D mesh-графіків.</li>
<li>Результат збережено у файл.</li>
</ol>
<p>Лістинг 4</p>
<pre class="hljs"><code><div>img = imread(<span class="hljs-string">'rock.jpg'</span>);
gray_img = rgb2gray(img);
neg_img = imcomplement(gray_img);  <span class="hljs-comment">% негатив</span>

corr = xcorr2(neg_img, gray_img);  <span class="hljs-comment">% 2D автокореляційна функція</span>
coorN= normxcorr2(neg_img, gray_img); <span class="hljs-comment">% 2D нормалізована кореляція</span>

customPlot([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>], gray_img, <span class="hljs-string">'Відтінки сірого'</span>);
customPlot([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>], corr,     <span class="hljs-string">'автокореляційна'</span>);
customMesh([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], corr,     <span class="hljs-string">'автокореляційна'</span>);
customPlot([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], neg_img,  <span class="hljs-string">'Негатив'</span>);
customPlot([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], coorN,    <span class="hljs-string">'нормалізована'</span>);
customMesh([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>], coorN,    <span class="hljs-string">'нормалізована'</span>);

drawnow;
print(gcf, [mfilename(<span class="hljs-string">'fullpath'</span>) <span class="hljs-string">'.png'</span>], <span class="hljs-string">'-dpng'</span>, <span class="hljs-string">'-r300'</span>);
close(gcf);
</div></code></pre>
<p><img src="src/lr2_4.png" alt="alt text"><br>
Рис. 4 - Результ задачі 4</p>
<h3 id="%D0%BA%D1%80%D0%BE%D0%BA-5-%D0%B4%D0%BE%D0%BF%D0%BE%D0%BC%D1%96%D0%B6%D0%BD%D1%96-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%97">Крок 5. Допоміжні функції</h3>
<p>Для зручності побудови графіків і гістограм були реалізовані допоміжні функції:</p>
<ul>
<li><code>customHist</code> – виведення зображень і їх гістограм;</li>
<li><code>customPlot</code> – відображення зображень і матриць у потрібному підграфіку;</li>
<li><code>customMesh</code> – побудова 3D-графіків (mesh) для великих матриць із зменшенням розміру для швидкості роботи.</li>
</ul>
<p>Лістинг 5</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">customHist</span><span class="hljs-params">(images, titles, map)</span></span>
    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(images)
        img_k = images{k};
        t = titles{k};
        <span class="hljs-built_in">i</span> = (k<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>;
        
        subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isempty</span>(map)
            imshow(img_k); 
        <span class="hljs-keyword">else</span>
            imshow(img_k, map); 
        <span class="hljs-keyword">end</span>
        title([<span class="hljs-string">'Зображення: '</span> t]);
        
        subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">2</span>); imhist(img_k);  title([<span class="hljs-string">'Гістограма: '</span> t]);
    <span class="hljs-keyword">end</span>

    drawnow;
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Лістинг 5</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">customPlot</span><span class="hljs-params">(pos, im, t)</span></span>
    ax = subplot(pos(<span class="hljs-number">1</span>), pos(<span class="hljs-number">2</span>), pos(<span class="hljs-number">3</span>));
    
    <span class="hljs-keyword">if</span> ~isa(im,<span class="hljs-string">'uint8'</span>) &amp;&amp; ~isa(im,<span class="hljs-string">'uint16'</span>)  <span class="hljs-comment">% якщо не клас зображення</span>
        imagesc(ax, im); 
        axis(ax, <span class="hljs-string">'image'</span>); 
        colorbar(ax);
        colormap(ax, jet);  <span class="hljs-comment">% кольорова карта для матриці</span>
    <span class="hljs-keyword">else</span>
        imshow(im, <span class="hljs-string">'Parent'</span>, ax); 
        colormap(ax, gray);  <span class="hljs-comment">% сірі відтінки для зображення</span>
    <span class="hljs-keyword">end</span>
    title(ax, t);
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Лістинг 5</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">customMesh</span><span class="hljs-params">(pos, c, t)</span></span>
    max_size = <span class="hljs-number">100</span>; <span class="hljs-comment">% максимальний розмір для mesh, бо ноуту погано :(</span>
    [h, w] = <span class="hljs-built_in">size</span>(c);

    row_idx = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">linspace</span>(<span class="hljs-number">1</span>, h, <span class="hljs-built_in">min</span>(h,max_size)));
    col_idx = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">linspace</span>(<span class="hljs-number">1</span>, w, <span class="hljs-built_in">min</span>(w,max_size)));
    c_small = c(row_idx, col_idx);
    
    ax = subplot(pos(<span class="hljs-number">1</span>), pos(<span class="hljs-number">2</span>), pos(<span class="hljs-number">3</span>));
    mesh(ax, c_small);  
    title(ax, t); 
    xlabel(ax,<span class="hljs-string">'X'</span>); ylabel(ax,<span class="hljs-string">'Y'</span>); 
    <span class="hljs-comment">% zlabel(ax, labelZ);</span>
    colormap(ax, jet);
<span class="hljs-keyword">end</span>
</div></code></pre>
<h3 id="%D0%B2%D0%B8%D1%81%D0%BD%D0%BE%D0%B2%D0%BE%D0%BA">Висновок</h3>
<p>У ході лабораторної роботи було вивчено основні функції аналізу зображень у середовищі MatLab.<br>
Отримано практичні навички перетворення зображень у півтонові та палітрові, виконано еквалізацію гістограм яскравості.<br>
Досліджено взаємну кореляцію між оригінальними, повернутими та негативними зображеннями.<br>
Практичне застосування дозволило закріпити знання щодо гістограм, еквалізації та методів кореляційного аналізу.</p>
<h3 id="%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D1%96-%D0%B7%D0%B0%D0%BF%D0%B8%D1%82%D0%B0%D0%BD%D0%BD%D1%8F">Контрольні запитання</h3>
<ol>
<li>
<p>Що таке гістограма?<br>
Розподіл яскравостей пікселів зображення у вигляді графіка.</p>
</li>
<li>
<p>Яка функція використовується для отримання гістограми?<br>
<code>imhist</code>.</p>
</li>
<li>
<p>У чому відмінність гістограми півтонового зображення від гістограми палітрового зображення?<br>
У півтоновому – відображає розподіл рівнів яскравості, у палітровому – залежить від кількості кольорів у палітрі.</p>
</li>
<li>
<p>Що таке еквалізація зображення?<br>
Вирівнювання гістограми для підвищення контрастності.</p>
</li>
<li>
<p>Яка функція виконує еквалізацію?<br>
<code>histeq</code>.</p>
</li>
<li>
<p>Назвіть способи виклику еквалізації.<br>
Використання функції <code>histeq</code> для півтонових і палітрових зображень.</p>
</li>
<li>
<p>У чому сенс кореляційного аналізу сигналів?<br>
У виявленні подібності та збігу між сигналами або зображеннями.</p>
</li>
<li>
<p>Які функції кореляційного аналізу ви знаєте?<br>
<code>xcorr2</code>, <code>normxcorr2</code>.</p>
</li>
</ol>

</body>

</html>